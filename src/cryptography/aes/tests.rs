#[cfg(test)]
use crate::cryptography::aes;

#[test]
fn rot_word() {
    assert_eq!(0xcf4f3c09, aes::rot_word(0x09cf4f3c));
}

#[test]
fn sub_word() {
    assert_eq!(0x8a84eb01, aes::sub_word(0xcf4f3c09));
}

#[test]
fn expand_128_key() {
    let key = [0x2b7e1516, 0x28aed2a6, 0xabf71588, 0x09cf4f3c];
    let w = aes::key_expansion(&key);
    let w_expected: [u32; 44] = [
        0x2b7e1516, 0x28aed2a6, 0xabf71588, 0x09cf4f3c, 0xa0fafe17, 0x88542cb1, 0x23a33939,
        0x2a6c7605, 0xf2c295f2, 0x7a96b943, 0x5935807a, 0x7359f67f, 0x3d80477d, 0x4716fe3e,
        0x1e237e44, 0x6d7a883b, 0xef44a541, 0xa8525b7f, 0xb671253b, 0xdb0bad00, 0xd4d1c6f8,
        0x7c839d87, 0xcaf2b8bc, 0x11f915bc, 0x6d88a37a, 0x110b3efd, 0xdbf98641, 0xca0093fd,
        0x4e54f70e, 0x5f5fc9f3, 0x84a64fb2, 0x4ea6dc4f, 0xead27321, 0xb58dbad2, 0x312bf560,
        0x7f8d292f, 0xac7766f3, 0x19fadc21, 0x28d12941, 0x575c006e, 0xd014f9a8, 0xc9ee2589,
        0xe13f0cc8, 0xb6630ca6,
    ];
    assert_eq!(w_expected, *w);
}

#[test]
fn add_round_key() {
    let mut state = [
        0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96, 0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17,
        0x2A,
    ];
    let round_key = [0x2B7E1516, 0x28AED2A6, 0xABF71588, 0x09CF4F3C];
    aes::add_round_key(&mut state, &round_key);
    let state_expected = [
        0x40, 0xBF, 0xAB, 0xF4, 0x06, 0xEE, 0x4D, 0x30, 0x42, 0xCA, 0x6B, 0x99, 0x7A, 0x5C, 0x58,
        0x16,
    ];
    assert_eq!(state_expected, state);
}

#[test]
fn shift_rows() {
    let mut state = [
        0x09, 0x08, 0x62, 0xBF, 0x6F, 0x28, 0xE3, 0x04, 0x2C, 0x74, 0x7F, 0xEE, 0xDA, 0x4A, 0x6A,
        0x47,
    ];
    aes::shift_rows(&mut state);
    let state_expected = [
        0x09, 0x28, 0x7F, 0x47, 0x6F, 0x74, 0x6A, 0xBF, 0x2C, 0x4A, 0x62, 0x04, 0xDA, 0x08, 0xE3,
        0xEE,
    ];
    assert_eq!(state_expected, state);
}

#[test]
fn multiply_galois() {
    assert_eq!(0xfe, aes::galois_multiply(0x57, 0x13));
}

#[test]
fn double_galois() {
    assert_eq!(0x15, aes::galois_multiply(0x87, 0x2));
}

#[test]
fn triple_galois() {
    assert_eq!(0xa4, aes::galois_multiply(0x95, 0x3));
}

#[test]
fn mix_columns() {
    let mut state = [
        0x09, 0x28, 0x7F, 0x47, 0x6F, 0x74, 0x6A, 0xBF, 0x2C, 0x4A, 0x62, 0x04, 0xDA, 0x08, 0xE3,
        0xEE,
    ];
    aes::mix_columns(&mut state);
    let state_expected = [
        0x52, 0x9F, 0x16, 0xC2, 0x97, 0x86, 0x15, 0xCA, 0xE0, 0x1A, 0xAE, 0x54, 0xBA, 0x1A, 0x26,
        0x59,
    ];
    assert_eq!(state_expected, state);
}

#[test]
fn sub_bytes() {
    let mut state = [
        0x40, 0xBF, 0xAB, 0xF4, 0x06, 0xEE, 0x4D, 0x30, 0x42, 0xCA, 0x6B, 0x99, 0x7A, 0x5C, 0x58,
        0x16,
    ];
    aes::sub_bytes(&mut state);
    let state_expected = [
        0x09, 0x08, 0x62, 0xBF, 0x6F, 0x28, 0xE3, 0x04, 0x2C, 0x74, 0x7F, 0xEE, 0xDA, 0x4A, 0x6A,
        0x47,
    ];
    assert_eq!(state_expected, state);
}

#[test]
fn cipher() {
    let block = [
        0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96, 0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17,
        0x2A,
    ];
    let key = [0x2B7E1516, 0x28AED2A6, 0xABF71588, 0x09CF4F3C];
    let w = aes::key_expansion(&key);
    let intermediate_values = aes::cipher(&block, &w);
    let cipher_text_expected = [
        0x3A, 0xD7, 0x7B, 0xB4, 0x0D, 0x7A, 0x36, 0x60, 0xA8, 0x9E, 0xCA, 0xF3, 0x24, 0x66, 0xEF,
        0x97,
    ];
    assert_eq!(
        cipher_text_expected,
        *intermediate_values.final_add_round_key
    );
}

#[test]
fn inv_shift_rows() {
    let mut state = [
        0x47, 0x40, 0xa3, 0x4c, 0x37, 0xd4, 0x70, 0x9f, 0x94, 0xe4, 0x3a, 0x42, 0xed, 0xa5, 0xa6,
        0xbc,
    ];
    aes::shift_rows(&mut state);
    aes::inv_shift_rows(&mut state);
    let state_expected = [
        0x47, 0x40, 0xa3, 0x4c, 0x37, 0xd4, 0x70, 0x9f, 0x94, 0xe4, 0x3a, 0x42, 0xed, 0xa5, 0xa6,
        0xbc,
    ];
    assert_eq!(state_expected, state);
}

#[test]
fn inv_sub_bytes() {
    let mut state = [
        0x47, 0x40, 0xa3, 0x4c, 0x37, 0xd4, 0x70, 0x9f, 0x94, 0xe4, 0x3a, 0x42, 0xed, 0xa5, 0xa6,
        0xbc,
    ];
    aes::sub_bytes(&mut state);
    aes::inv_sub_bytes(&mut state);
    let state_expected = [
        0x47, 0x40, 0xa3, 0x4c, 0x37, 0xd4, 0x70, 0x9f, 0x94, 0xe4, 0x3a, 0x42, 0xed, 0xa5, 0xa6,
        0xbc,
    ];
    assert_eq!(state_expected, state);
}

#[test]
fn inv_mix_columns() {
    let mut state = [
        0x47, 0x40, 0xa3, 0x4c, 0x37, 0xd4, 0x70, 0x9f, 0x94, 0xe4, 0x3a, 0x42, 0xed, 0xa5, 0xa6,
        0xbc,
    ];
    aes::mix_columns(&mut state);
    aes::inv_mix_columns(&mut state);
    let state_expected = [
        0x47, 0x40, 0xa3, 0x4c, 0x37, 0xd4, 0x70, 0x9f, 0x94, 0xe4, 0x3a, 0x42, 0xed, 0xa5, 0xa6,
        0xbc,
    ];
    assert_eq!(state_expected, state);
}

#[test]
fn inv_cipher() {
    let block = [
        0x3A, 0xD7, 0x7B, 0xB4, 0x0D, 0x7A, 0x36, 0x60, 0xA8, 0x9E, 0xCA, 0xF3, 0x24, 0x66, 0xEF,
        0x97,
    ];
    let key = [0x2B7E1516, 0x28AED2A6, 0xABF71588, 0x09CF4F3C];
    let w = aes::key_expansion(&key);
    let intermediate_values = aes::inv_cipher(&block, &w);
    let block_expected = [
        0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96, 0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17,
        0x2A,
    ];
    assert_eq!(block_expected, *intermediate_values.final_add_round_key);
}

#[test]
fn correctness_192() {
    let block = [
        0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96, 0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17,
        0x2A,
    ];
    let key = [
        0x8E73B0F7, 0xDA0E6452, 0xC810F32B, 0x809079E5, 0x62F8EAD2, 0x522C6B7B,
    ];
    assert_eq!(
        block,
        *aes::decrypt(&aes::encrypt(&block, &key).final_add_round_key, &key).final_add_round_key
    );
}

#[test]
fn correctness_256() {
    let block = [
        0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96, 0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17,
        0x2A,
    ];
    let key = [
        0x603DEB10, 0x15CA71BE, 0x2B73AEF0, 0x857D7781, 0x1F352C07, 0x3B6108D7, 0x2D9810A3,
        0x0914DFF4,
    ];
    assert_eq!(
        block,
        *aes::decrypt(&aes::encrypt(&block, &key).final_add_round_key, &key).final_add_round_key
    );
}
